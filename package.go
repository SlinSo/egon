package egon

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
)

// Package represents a collection of ego templates in a single package.
type Package struct {
	Name      string
	Templates []*Template
}

// Write writes out the package header and templates to a writer.
func (p *Package) Write(w io.Writer) error {
	if err := p.writeHeader(w); err != nil {
		return err
	}

	for _, t := range p.Templates {
		if err := t.Write(w); err != nil {
			return fmt.Errorf("template: %s: %s", t.Path, err)
		}
	}

	return nil
}

// Writes the package name and consolidated header blocks.
func (p *Package) writeHeader(w io.Writer) error {
	if p.Name == "" {
		return errors.New("package name required")
	}

	// Write naive header first.
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "package %s\n", p.Name)
	for _, t := range p.Templates {
		for _, b := range t.headerBlocks() {
			b.write(&buf)
		}
	}

	// Parse header into Go AST.
	f, err := parser.ParseFile(token.NewFileSet(), "ego.go", buf.String(), parser.ImportsOnly)
	if err != nil {
		fmt.Println(buf.String())
		return fmt.Errorf("writeHeader: %s", err)
	}

	// Reset buffer.
	buf.Reset()

	// Add note that the file is auto-generated
	fmt.Fprintf(&buf, "// Generated by egon.\n")
	fmt.Fprintf(&buf, "// DO NOT EDIT\n\n")

	fmt.Fprintf(&buf, "package %s\n", p.Name)

	// Write deduped imports.
	var decls = map[string]bool{`:"fmt"`: true, `:"io"`: true}
	fmt.Fprint(&buf, "import (\n")
	fmt.Fprintln(&buf, `"fmt"`)
	for _, t := range p.Templates {
		if t.hasEscapedPrintBlock() {
			fmt.Fprintln(&buf, `"html"`)
			decls["html"] = true
			break
		}
	}
	fmt.Fprintln(&buf, `"io"`)

	for _, d := range f.Decls {
		d, ok := d.(*ast.GenDecl)
		if !ok || d.Tok != token.IMPORT {
			continue
		}

		for _, s := range d.Specs {
			s := s.(*ast.ImportSpec)
			var id string
			if s.Name != nil {
				id = s.Name.Name
			}
			id += ":" + s.Path.Value

			// Ignore any imports which have already been imported.
			if decls[id] {
				continue
			}
			decls[id] = true

			// Otherwise write it.
			if s.Name == nil {
				fmt.Fprintf(&buf, "%s\n", s.Path.Value)
			} else {
				fmt.Fprintf(&buf, "%s %s\n", s.Name.Name, s.Path.Value)
			}
		}
	}
	fmt.Fprint(&buf, ")\n")

	// Write out to writer.
	buf.WriteTo(w)

	return nil
}
